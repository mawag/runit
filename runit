#!/bin/bash

# 处理信号
# `runit`可以接收SIGINT和SIGTERM信号
trap "do_exit" SIGINT SIGTERM

#init
readonly RUNIT_VERSION="version 0.1"

readonly DEFAULT_PROC="Procfile"
readonly DEFAULT_ENV=".env"
readonly LOG_DATE_FORMAT='+%H:%M:%S'
# default
PORT="8080"

# 记录运行的pid
declare -a app_run_pid
declare -a app_name
app_run_number=0
envfile=""

# ERROR Code
EXIT_SUCCESS=0
OPTIND_ERROR=1000
CONFIG_ERROR=1001
PORT_ERROR=3001

PROCFILE_NOT_FOUND=1404
PROCFILE_CANOT_READ=1502
PROCFILE_ERROR=1500

ENVFILE_NOT_FOUND=2404
ENVFILE_CANOT_READ=2502
ENVFILE_ERROR=2500


# 校验正则
readonly LINE_ZHUSHI='^\s*#.*$'
readonly LINE_NONE='^\s*$'
readonly LINE_PROC='^\s*\w+:\s*.+$'
readonly LINE_ENV="^[A-Za-z]+\w*=(\`.*\`|\".*\"|'.*'|\w+)$"
readonly LINE_USE_PORT='^.*\$PORT$'

# Color
HIGHLIGHT='\033[1m'
F_BLACK='\033[30;47m'
B_BLACK='\033[40m'
F_RED='\033[31m'
B_RED='\033[41m'
F_GREEN='\033[32m'
B_GREEN='\033[42m'
F_YELLOW='\033[33m'
B_YELLOW='\033[43m'
F_BLUE='\033[34m'
B_BLUE='\033[44m'
F_MAGENTA='\033[35m'
B_MAGENTA='\033[45m'
F_CYAN='\033[36m'
B_CYAN='\033[46m'
F_WHITE='\033[37m'
B_WHITE='\033[47m'
RESET='\033[0m'

readonly LOG_COLOR=("$F_CYAN" "$F_MAGENTA" "$F_BLUE" "$F_YELLOW" "$F_GREEN")


#over
function do_exit(){
    echo "Will Over"
    for app_pid in ${app_run_pid[@]} 
    do
        echo "kill ${app_pid}"
        kill "${app_pid}"
    done
    wait
    echo "----------End------------"
}

# 用法提示
function usage() {
		echo "Usage: runit [-c] [-f procfile|Procfile] [-e envfile|.env]"
		echo "Runit Version: $RUNIT_VERSION"
}


# 错误输出
function errecho() {
    #color=${2:-$F_RED}
	#echo -e "${color}${HIGHLIGHT}[$(date +'%Y-%m-%d %H:%M:%S %Z')] $1$RESET" >&2
	
	log "Runit" "$1" ${F_RED}${HIGHLIGHT}
}

# env & procfile 校验
function verify() {
    local ischeck=$1
	local procfile=${2:-$DEFAULT_PROC}
	local env_file=$3
	local env_isok=true
	local proc_isok=true
	local envfile

	#如果存在env参数,或者默认env存在，强校验
	if [[ -n "${env_file}" ]] || [[ -e "${DEFAULT_ENV}" ]];then
		envfile=${env_file:-${DEFAULT_ENV}}
		${ischeck} && echo "ENV file Start Check"
		
	    # for bug in line end with 0x0a
	    # bug info at #1
		# 2018-01-24
		local line_number=0
		while read line; do
			let line_number++
		done < "${envfile}"
		if [[ $line_number = 0 ]]; then
			echo "" >> ${envfile}
		fi
		
    	let line_number=0
    	
		while read line; do
			let line_number++
			if [[ "${line}" =~ ${LINE_ZHUSHI} ]]; then
				${ischeck} && echo "- Line ${line_number} is 注释"
			elif [[ "${line}" =~ ${LINE_NONE} ]]; then
				${ischeck} && echo "- Line ${line_number} is 空行"
			elif [[ "${line}" =~ ${LINE_ENV} ]]; then
				${ischeck} && echo "- Line ${line_number} is Env Config"
			else
				errecho "${envfile} line ${line_number} has ERROR!: ${line}"
				env_isok=false
			fi
		done < <(grep "" "${envfile}")
		if  ${env_isok} ; then
    	    ${ischeck} && echo "ENV file \"${envfile}\" is ok"
    	else
    	    errecho "ENV file \"${envfile}\" is error"
    	fi
	fi


	#PROC file
	if [ -e ${procfile} ]; then
	    ${ischeck} && echo "Procfile file Start Check"
	    
	    # for bug in line end with 0x0a
	    # bug info at #1
		# 2018-01-24
		local line_number=0
		# while read line; do
		# 	let line_number++
		# done < "${procfile}"
		# if [[ $line_number = 0 ]]; then
		# 	echo "" >> ${procfile}
		# fi
		# let line_number=0
    	
    	while read line; do
    		let line_number++
    		if [[ "${line}" =~ ${LINE_ZHUSHI} ]]; then
    			${ischeck} && echo "- Line ${line_number} is 注释"
    		elif [[ "${line}" =~ ${LINE_NONE} ]]; then
    			${ischeck} && echo "- Line ${line_number} is 空行"
    		elif [[ "${line}" =~ ${LINE_PROC} ]]; then
    			${ischeck} && echo "- Line ${line_number} is Proc"
    		else
    			echo "${procfile} Line ${line_number} is ERROR. Content is |->${line}<-|"
    			proc_isok=false
    		fi
    	done < <(grep "" "${procfile}")
    	if  ${proc_isok}  ; then
    	    ${ischeck} && echo "Procfile \"${procfile}\" is ok"
    	else
    	    errecho "Procfile \"${procfile}\" is error"
    	fi
	else
		errecho "Procfile Not Found"
		exit $PROCFILE_NOT_FOUND
	fi

    if  ${env_isok}  &&  ${proc_isok}  ; then
		${ischeck} && echo "Config access check." && exit $EXIT_SUCCESS
	else
		${ischeck} && errecho "Config can\`t access check."
	    exit $CONFIG_ERROR
    fi
}


# log输出
# 所有输出信息
function log() {
	local time=$(date "${LOG_DATE_FORMAT}")
	local default_app="Runit"
	local default_msg="No message passed."
	app=${1:-$default_app}
	message=${2:-$default_msg}
	color=${3:-$F_WHITE}

	#echo -e "$HIGHLIGHT$color$time $app\t| $message $RESET"
	printf "$color[ %s ] %-10s| $RESET" ${time} ${app}
	echo -e "$message"
	return
}


# 运行command
# 需添加对port的校验，如果调用自动增加,需要对子进程输出日志的处理
function run_command() {
	local appname="$1"
	local appcommand="$2"
	local log_color="$3"

	if [[ -f $envfile ]]; then
		appcommand="source ${envfile};${appcommand}"
	fi

	bash -c "${appcommand}" > >(
		while read line; do
			log "${appname}" "${line}" "${log_color}"
		done
	) 2>&1 &


	local pid=$!
	log "${appname}" "${appcommand} started with pid ${pid}" "${log_color}"
	app_run_pid[$app_run_number]=${pid}
	app_name[$app_run_number]=$appname

	if [[ $appcommand =~ $LINE_USE_PORT ]]; then
		let PORT++
	fi
	
	return
}


#加载env
#参数：
function  load_env_file() {
	# local envfile=$1
	
	if [[ -e "${envfile}" ]];then
	# 	local envfile=${envfile:-${DEFAULT_ENV}}
		source ${envfile} > /dev/null 2>&1
		local isok=$?
		if [[ ${isok} = 0 ]]; then
		    :
		    #log "Runit" "ENV file \"${envfile}\" load success"
		else
		    errecho "ENV file load ERROR"
		fi
		return
		# while read line;do
		#     eval "$line"
		# done < $ENV_FILE
	fi
}

# 处理运行Procfile部分
function run_procfile() {
	local procfile="${1:-$DEFAULT_PROC}"
	local run_app_number=0

	#log "Runit" "Procfile load Start:${procfile}"
	while read line; do
        if [[ "${line}" =~ $LINE_PROC ]]; then
			local appname="${line%%:*}"
			local appcommand="${line#*:}"
			run_command "${appname}" "${appcommand}" ${LOG_COLOR[((${run_app_number}%5))]}
			let run_app_number++
		fi
	done < <(grep "" "${procfile}")
	return
}

function main() {
	local verify_flag=false
	while getopts ':cf:e:h' opts; do
		case "${opts}" in
			c)
				verify_flag=true
				;;
			f)
				if [ -e "$OPTARG" ];then
						readonly PROC_FILE=$OPTARG;
				else
						errecho "Procfile Not Found"
						exit $PROCFILE_NOT_FOUND;
				fi
				;;
			e)
				if [[ -e "$OPTARG" ]];then
						envfile=$OPTARG;
				else
						errecho "ENV file Not Found"
						exit $ENVFILE_NOT_FOUND;
				fi
				;;
			h)
				usage
				exit $EXIT_SUCCESS
				;;
			\?)
				usage
				exit $OPTIND_ERROR
				;;
			:)
				errecho "invalid option ${OPTARG}"
				usage
				exit $OPTIND_ERROR
				;;
		esac
	done
	
	if [[ -n "${envfile}" ]] || [[ -e "${DEFAULT_ENV}" ]];then
		envfile=${envfile:-${DEFAULT_ENV}}
	fi
	verify "${verify_flag}" "${PROC_FILE:-$DEFAULT_PROC}" "${envfile}"
	load_env_file "${envfile}"
	run_procfile "${PROC_FILE:-$DEFAULT_PROC}" "${envfile}"
	wait
}

main "$@"
